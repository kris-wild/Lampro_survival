
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ismin</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-07-09"><meta name="DC.source" content="ismin.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ismin</h1><!--introduction--><p>checks if a parameter combination is at a local minimum of the loss function</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Syntax</a></li><li><a href="#4">Description</a></li><li><a href="#5">Remarks</a></li><li><a href="#6">Example of use</a></li></ul></div><h2 id="3">Syntax</h2><p>[info, lf] = <a href="../ismin.m"><b>ismin</b></a> (my_pet, del)</p><h2 id="4">Description</h2><p>checks if a parameter combination is at a local minimum of the loss function by comparing its value against values where all free parameters are multiplied by 1-del, 1 and 1+del independently, which gives 3^n combinations for n free parameters.</p><p>Input</p><div><ul><li>my_pet: char string with name of pet</li><li>del: optional scalar with perturbation factor (default 0.05)</li></ul></div><p>Output</p><div><ul><li>info: boolean: true if local minimum, false if not</li><li>lf: scalar with value of the loss function</li></ul></div><h2 id="5">Remarks</h2><p>Assumes local existence of my_data_my_pet, pars_init_my_pet, predict_my_pet. This function only works for lossfunction_sb and is really computationally intensive if number of free parameter exceeds 6;</p><h2 id="6">Example of use</h2><p>First copy add_my_pet/entries/Dipodomys_deserti to local and reduce # free pars by editing pars_init: ismin('Dipodomys_deserti', 0.05);</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ismin
% checks if a parameter combination is at a local minimum of the loss function
%%
function [info, lf] = ismin(my_pet, del)
  %  created at 2022/07/07 by Bas Kooijman
  
  %% Syntax
  % [info, lf] = <../ismin.m *ismin*> (my_pet, del)
  
  %% Description
  % checks if a parameter combination is at a local minimum of the loss function 
  % by comparing its value against values where all free parameters are multiplied 
  % by 1-del, 1 and 1+del independently, which gives 3^n combinations for n free parameters. 
  % 
  % Input
  %
  % * my_pet: char string with name of pet
  % * del: optional scalar with perturbation factor (default 0.05)
  %
  % Output
  %
  % * info: boolean: true if local minimum, false if not
  % * lf: scalar with value of the loss function
  
  %% Remarks
  % Assumes local existence of my_data_my_pet, pars_init_my_pet, predict_my_pet.
  % This function only works for lossfunction_sb 
  % and is really computationally intensive if number of free parameter exceeds 6;
  
  %% Example of use
  % First copy add_my_pet/entries/Dipodomys_deserti to local and reduce # free pars by editing pars_init: 
  % ismin('Dipodomys_deserti', 0.05);
  
  if ~exist('del','var')
    del = 0.05;
  end
  
  % initiate par,data,auxData,weights for calls to lossfunction
  % the free pars in par will be overwritten
  eval(['[data_st, auxData, metaData, txtData, weights] = mydata_', my_pet,';']);
  eval(['[par, metaPar, txtPar] = pars_init_', my_pet, '(metaData);']);  
  func = ['predict_', my_pet];
  free = par.free; parNm = fields(free); % par names
  n_par = length(parNm); i_free = [];
  for i = 1:n_par; if free.(parNm{i}); i_free = [i_free, i]; end; end
  n_free = length(i_free);
  
  % catenate dependent data, weights in a single vector
  nm = fieldnmnst_st(data_st); % names of data sets
  data = data_st; psd = data.psd; data = rmfield(data, 'psd'); % copy to remove independent data
  for i = 1:length(fields(data))
    if size(size(data.(nm{i})),2) == 2 && size(data.(nm{i}),2) > 1
      data.(nm{i})(:,1) = []; 
    end 
  end
  data.psd = psd; [data, meanData] = struct2vector(data, nm);
  weights = struct2vector(weights, nm);
  sel = ~isnan(data); % fill sel to exclude NaN's in data
  
  % compose txt to fill perturbation factors pert in nested loops, here for example with n=3 
  % txt = 'for i1=-1:1;for i2=-1:1;for i3=-1:1;k=k+1;pert(k,:)=[1+del*i1, 1+del*i2, 1+del*i3];end;end;end'
  n_pert = 3^n_free; % # of perturbations
  i_ref = round(n_pert/2 + 0.5); % row-index of pert with all ones
  pert = zeros(n_pert, n_free); val = zeros(n_pert,1); k = 0;   txt=''; % initiate
  for i=1:n_free
    txt = [txt, 'for i', num2str(i), '=-1:1;'];
  end
  txt = [txt, 'k=k+1; pert(k,:)=['];
  for i=1:n_free
    txt = [txt, '1+del*i', num2str(i), ','];
  end
  txt(end) = ']';
  for i=1:n_free
    txt = [txt, ';end'];
  end
  eval(txt); % fill perturbation factors
  
  % get loss function sb for perturbed pars
  par = rmfield(par, 'free'); par_ref = par; % copy par-structure to reference
  for i = 1:n_pert
    for j = 1:n_free; par.(parNm{j}) = par_ref.(parNm{j}) * pert(i,j); end
    %val(i) = lossFn(func, par, data, auxData, weights);
    f = feval(func, par, data_st, auxData);
    f = predict_pseudodata(par, data_st, f);
    [prdData, meanPrdData] = struct2vector(f, nm);
    val(i) = weights(sel)' * ((data(sel) - prdData(sel)).^2 ./ (meanData(sel).^2 + meanPrdData(sel).^2));
    %fprintf([num2str(i), ' ', num2str(val(i)), '\n']);
  end
  %
  lf = val(i_ref); % value of loss function at un-perturbed parameter combination
  info = all(lf <= val);
    
  figure(1) % plot survivor function of loss function values
  xy = surv(val); plot(xy(:,1),xy(:,2),'r');
  hold on
  plot([lf; lf], [0; 1], 'g');
  set(gca, 'FontSize', 15, 'Box', 'on')
  xlabel('loss function at perturbed parameters') 

end

function [vec, meanVec] = struct2vector(struct, fieldNames)
  vec = []; meanVec = [];
  for i = 1:size(fieldNames, 1)
    fieldsInCells = textscan(fieldNames{i},'%s','Delimiter','.');
    aux = getfield(struct, fieldsInCells{1}{:}); aux = aux(:); 
    vec = [vec; aux(~isnan(aux))];
    meanVec = [meanVec; ones(length(aux), 1) * mean(aux)];
  end
end
##### SOURCE END #####
--></body></html>