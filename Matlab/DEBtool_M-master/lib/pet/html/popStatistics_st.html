
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>popStatistics_st</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-02-21"><meta name="DC.source" content="popStatistics_st.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">popStatistics_st</a></li><li><a href="#3">Syntax</a></li><li><a href="#4">Description</a></li><li><a href="#5">Remarks</a></li><li><a href="#6">Example of use</a></li></ul></div><h2 id="1">popStatistics_st</h2><p>Computes implied population properties of DEB models</p><h2 id="3">Syntax</h2><p>[stat, Hfig_surv, Hfig_stab] = <a href="../popStatistics_st.m"><b>popStatistics_st</b></a>(model, par, T, f)</p><h2 id="4">Description</h2><p>Computes quantities that depend on parameters, temperature and food level at population level. First-level field is scaled func resp (f0, ff, f1, where ff is optional), second thinning (thin0, thin1), third gender(f,m, where m is optional) View results with prt_my_pet_pop, which is a shell around this function. The allowed models are: std, stf, stx, ssj, sbp, abj, asj, abp, hep, hex. If 4th input is a character string, it should specify a fraction for f in the interval (f_min, 1), i.e. f_min + f * (1 - f_min)</p><p>Input</p><div><ul><li>model: string with name of model</li><li>par :  structure with primary parameters at reference temperature in time-length-energy frame</li><li>T:     optional scalar with temperature in Kelvin; default C2K(20)</li><li>F:     optional scalar scaled functional response (default 1), or character string representing a fraction</li></ul></div><p>Output</p><div><ul><li>stat: structure with statistics (see under remarks) with fields, units and labels</li></ul></div><pre>   - f: scaled function response (set by input F)
   - T: absolute temperature (set by input)
   - TC: temperature correction factor</pre><pre>   for with and without thinning, at f_min, f and f_max
   - f:  scaled functional response
   - r:  population growth rate
   - t2: population doubling time
   - S_b: survivor probability at birth
   - S_p: survivor probability at puberty
   - theta_e: fraction of individuals that is embryo
   - theta_j: fraction of individuals that is juvenile
   - theta_s: fraction of individuals that is adult
   - L_bi: mean structural length of post-natals
   - L2_bi: mean squared structural length of post-natals
   - L3_bi: mean cubed structural length of post-natals
   - Ww_bi: mean wet weight of post-natals
   - L_pi: mean structural length of adults
   - L2_pi: mean squared structural length of adults
   - L3_pi: mean cubed structural length of adults
   - Ww_pi: mean wet weight of adults
   - Y_PX: yield of faeces on food
   - Y_VX: yield of living structure on food
   - Y_VX_d: yield of dead structure on food
   - Y_EP: yield of living reserve on food
   - Y_EP_d: yield of dead reserve on food
   - mu_hx: yield of heat on food
   - Y_CX: yield of CO2 on food
   - Y_HX: yield of H2O on food
   - Y_OX: yield of O2 on food
   - Y_NX: yield of N-waste on food
   - R: mean reproduction rate of adults
   - J_X: mean ingestion rate of wet food by post-natals</pre><div><ul><li>Hfig_surv: figure handle for survivor probabilities</li><li>Hfig_stab: figure handle for atable age distributions</li></ul></div><h2 id="5">Remarks</h2><p>Assumes that parameters are given in standard units (d, cm, mol, J, K); this is not checked! Ages exclude initial delay of development, if it would exist. Body weights exclude possible contribution of the reproduction buffer. The background hazards, if specified in par, are assumed to correspond with T_typical, not with T_ref The labels and units are avilable in the (static) structures AmPdata/allUnits.mat and allLabel.mat</p><p>For required model-specific fields, see <a href="get_parfields.html"><b>get_parfields</b></a>.</p><h2 id="6">Example of use</h2><p>load('results_species.mat'); [stat, txtStat] = popStatistics_st(metaPar.model, par); printstat_st(stat, txtStat)</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% popStatistics_st
% Computes implied population properties of DEB models

function [stat, Hfig_surv, Hfig_stab] = popStatistics_st(model, par, T, F) 
% created 2019/07/08 by Bas Kooijman, modified 2020/02/21

%% Syntax
% [stat, Hfig_surv, Hfig_stab] = <../popStatistics_st.m *popStatistics_st*>(model, par, T, f)

%% Description
% Computes quantities that depend on parameters, temperature and food level at population level.
% First-level field is scaled func resp (f0, ff, f1, where ff is optional), second thinning (thin0, thin1), third gender(f,m, where m is optional)
% View results with prt_my_pet_pop, which is a shell around this function.
% The allowed models are: std, stf, stx, ssj, sbp, abj, asj, abp, hep, hex.
% If 4th input is a character string, it should specify a fraction for f in the interval (f_min, 1), i.e. f_min + f * (1 - f_min)
%
% Input
%
% * model: string with name of model
% * par :  structure with primary parameters at reference temperature in time-length-energy frame
% * T:     optional scalar with temperature in Kelvin; default C2K(20)
% * F:     optional scalar scaled functional response (default 1), or character string representing a fraction
% 
% Output
% 
% * stat: structure with statistics (see under remarks) with fields, units and labels
%
%     - f: scaled function response (set by input F)
%     - T: absolute temperature (set by input)
%     - TC: temperature correction factor
%
%     for with and without thinning, at f_min, f and f_max
%     - f:  scaled functional response
%     - r:  population growth rate
%     - t2: population doubling time
%     - S_b: survivor probability at birth
%     - S_p: survivor probability at puberty
%     - theta_e: fraction of individuals that is embryo
%     - theta_j: fraction of individuals that is juvenile
%     - theta_s: fraction of individuals that is adult
%     - L_bi: mean structural length of post-natals
%     - L2_bi: mean squared structural length of post-natals
%     - L3_bi: mean cubed structural length of post-natals
%     - Ww_bi: mean wet weight of post-natals
%     - L_pi: mean structural length of adults
%     - L2_pi: mean squared structural length of adults
%     - L3_pi: mean cubed structural length of adults
%     - Ww_pi: mean wet weight of adults
%     - Y_PX: yield of faeces on food
%     - Y_VX: yield of living structure on food
%     - Y_VX_d: yield of dead structure on food
%     - Y_EP: yield of living reserve on food
%     - Y_EP_d: yield of dead reserve on food
%     - mu_hx: yield of heat on food
%     - Y_CX: yield of CO2 on food
%     - Y_HX: yield of H2O on food
%     - Y_OX: yield of O2 on food
%     - Y_NX: yield of N-waste on food
%     - R: mean reproduction rate of adults
%     - J_X: mean ingestion rate of wet food by post-natals
%
% * Hfig_surv: figure handle for survivor probabilities
% * Hfig_stab: figure handle for atable age distributions

%% Remarks
% Assumes that parameters are given in standard units (d, cm, mol, J, K); this is not checked!
% Ages exclude initial delay of development, if it would exist.
% Body weights exclude possible contribution of the reproduction buffer.
% The background hazards, if specified in par, are assumed to correspond with T_typical, not with T_ref
% The labels and units are avilable in the (static) structures AmPdata/allUnits.mat and allLabel.mat
%
% For required model-specific fields, see <get_parfields.html *get_parfields*>.

%% Example of use
% load('results_species.mat'); [stat, txtStat] = popStatistics_st(metaPar.model, par); printstat_st(stat, txtStat)

  choices = {'std', 'stf', 'stx', 'ssj', 'sbp', 'abj', 'asj', 'abp', 'hep', 'hex'};
  if ~any(strcmp(model,choices))
    fprintf('warning from statistics_st: invalid model key \n')
    stat = []; 
    return;
  end    
     
  if ~exist('T', 'var') || isempty(T)
    T = C2K(20);   % K, body temperature
  end
 
  if ~exist('F', 'var') || isempty(F) || ( ~ischar(F) && F == 1) % overwrite f in par
    par.f = 1; n_fVal = 2;
  else
    par.f = F; n_fVal = 3;
  end
  
  if ~isfield(par, 'h_B0b')
    par.h_B0b = 0;
  end
  if ~isfield(par, 'h_Bbx')
    par.h_Bbx = 0;
  end
  if ~isfield(par, 'h_Bbs')
    par.h_Bbs = 0;
  end
  if ~isfield(par, 'h_Bbj')
    par.h_Bbj = 0;
  end
  if ~isfield(par, 'h_Bbp')
    par.h_Bbp = 0;
  end
  if ~isfield(par, 'h_Bsj')
    par.h_Bsj = 0;
  end
  if ~isfield(par, 'h_Bxp')
    par.h_Bxp = 0;
  end
  if ~isfield(par, 'h_Bsp')
    par.h_Bsp = 0;
  end
  if ~isfield(par, 'h_Bjp')
    par.h_Bjp = 0;
  end
  if ~isfield(par, 'h_Bpi')
    par.h_Bpi = 0;
  end
  if ~isfield(par, 'h_Bbj')
    par.h_Bpi = 0;
  end
  if ~isfield(par, 'h_Bje')
    par.h_Bpi = 0;
  end
  if ~isfield(par, 'h_Bei')
    par.h_Bpi = 0;
  end

  % unpack par and compute statisitics
  cPar = parscomp_st(par); vars_pull(par); vars_pull(cPar);  
  
  if any(ismember({'z_m','E_Hbm','E_Hsm','E_Hxm','E_Hjm','E_Hpm'},fieldnames(par)))
    male = 1; % male and females parameters differ
  else
    male = 0; % male and females parameters are the same
  end

  % temperature correction
  pars_T = T_A;
  if exist('T_L','var') && exist('T_AL','var')
    pars_T = [T_A; T_L; T_AL];
  end
  if exist('T_L','var') && exist('T_AL','var') && exist('T_H','var') && exist('T_AH','var')
    pars_T = [T_A; T_L; T_H; T_AL; T_AH]; 
  end
  TC = tempcorr(T, T_ref, pars_T); % -, Temperature Correction factor
  stat.T = K2C(T); stat.c_T = TC;  % add to stat, txtStat is updated below, since ssd_mod overwrites txtStat              
      
  % first females with and without thinning, possibly followed by males; 
  % for each thinning-setting: f_min, possibly f, and f_max (=1)
  par.thinning = 1;
  [f_01, info_01] = f_ris0_mod (model, par); % get f for r = 0
  stat.f0.thin1.f.f = f_01; r_01 = 0; stat.f0.thin1.f.r = r_01; stat.f0.thin1.f.t2 = NaN; 
  if info_01 == 0
    stat = ssd_mod(model, stat, '01f', NaN); f_01 = NaN; stat.f0.thin1.f.f = f_01;
  else % fill statistics
    stat = ssd_mod(model, stat, '01f', par, T, f_01, 0);
  end 
  if n_fVal == 3
    if ischar(F)
      f_f1 = str2double(F);
      if f_f1 < 0 || f_f1 > 1
        fprintf(['Warning from popStatistics_st: specified f = ', num2str(f_f1), ' is outside the interval (0,1)\n']);
        return
      end
      f_f1 = f_01 + f_f1 * (1 - f_01); % -, scaled function response
    else
      f_f1 = F;
    end
    if f_f1 < f_01
      fprintf(['Warning from popStatistics_st: specified f = ', num2str(f_f1), ' is smaller than minimum value ', num2str(f_01), '\n']);
      stat = []; txtStat = []; Hfig_surv = []; Hfig_stab = [];
      return
    end
    if isnan(f_f1)
      stat = ssd_mod(model, stat, 'f1f', NaN); stat.ff.thin1.f.f = f_f1;
    else
      [r_f1, info_f1] = sgr_mod (model, par, T, f_f1); 
      stat.ff.thin1.f.f = f_f1; stat.ff.thin1.f.r = r_f1; stat.ff.thin1.f.t2 = (log(2))/ r_f1;
    end
    if ~exist('info_f1', 'var') || info_f1 == 0
      stat = ssd_mod(model, stat, 'f1f', NaN); 
      stat.ff.thin1.f.r = NaN; stat.ff.thin1.f.t2 = NaN;
    else
      stat = ssd_mod(model, stat, 'f1f', par, T, f_f1, r_f1);
    end
  end
  [r_11, info_11] = sgr_mod (model, par, T, 1);
  stat.f1.thin1.f.f = 1; stat.f1.thin1.f.r = r_11; stat.f1.thin1.f.t2 = (log(2))/ r_11; 
  if info_11 == 0
    stat = ssd_mod(model, stat, '11f', NaN); 
    stat.f1.thin1.f.r = NaN; stat.f1.thin1.f.t2 = NaN;
  else
    stat = ssd_mod(model, stat, '11f', par, T, 1, r_11);
  end
            
  par.thinning = 0;
  [f_00, info_00] = f_ris0_mod (model, par); % get f for r = 0
  stat.f0.thin0.f.f = f_00; r_00 = 0; stat.f0.thin0.f.r = r_00; stat.f0.thin0.f.t2 = NaN; 
  if info_00 == 0
    stat = ssd_mod(model, stat, '00f', NaN); f_00 = NaN; stat.f0.thin0.f.f = f_00;
  else
    stat = ssd_mod(model, stat, '00f', par, T, f_00, 0);
  end
  if n_fVal == 3
    if ischar(F) && ~isnan(f_f1)
      f_f0 = f_f1; % f_00 + str2double(F) * (1 - f_00); % -, scaled function response
    elseif ischar(F)
      f_f0 = f_00 + str2double(F) * (1 - f_00); % -, scaled function response
    else
      f_f0 = F;
    end
    if isnan(f_f0)
      stat = ssd_mod(model, stat, 'f0f', NaN); stat.ff.thin0.f.f = f_f0;
    else
      [r_f0, info_f0] = sgr_mod (model, par, T, f_f0);
      stat.ff.thin0.f.f = f_f0; stat.ff.thin0.f.r = r_f0; stat.ff.thin0.f.t2 = (log(2))/ r_f0;
    end
    if ~exist('info_f0', 'var') || info_f0 == 0
      stat = ssd_mod(model, stat, 'f0f', NaN);
      stat.ff.thin0.f.r = NaN; stat.ff.thin0.f.t2 = NaN;
    else
      stat = ssd_mod(model, stat, 'f0f', par, T, f_f0, r_f0);
    end
  end
  [r_10, info_10] = sgr_mod (model, par, T, 1); 
  stat.f1.thin0.f.f = 1; stat.f1.thin0.f.r = r_10; stat.f1.thin0.f.t2 = (log(2))/ r_10;
  if info_10 == 0
    [stat, txtStat] = ssd_mod(model, stat, '10f', NaN); 
    stat.f1.thin0.f.r = NaN; stat.f1.thin0.f.t2 = NaN;
  else
    [stat, txtStat] = ssd_mod(model, stat, '10f', par, T, 1, r_10);
  end
            
  if male % overwrite of par!!!! parameters become male parameters
    if isfield(par,'z_m')
      par.z = par.z_m;
    end
    if isfield(par,'E_Hbm')
      par.E_Hb = par.E_Hbm;
    end
    if isfield(par,'E_Hjm')
      par.E_Hj = par.E_Hjm;
    end
    if isfield(par,'E_Hpm')
      par.E_Hp = par.E_Hpm;
    end
    
    par.thinning = 1; 
    stat.f0.thin1.m.f = stat.f0.thin1.f.f; stat.f0.thin1.m.r = stat.f0.thin1.f.r; stat.f0.thin1.m.t2 = stat.f0.thin1.f.t2; stat.f0.thin1.m.ER = [];
    if isnan(stat.f0.thin1.f.f) 
      stat = ssd_mod(model, stat, '01m', NaN); 
      stat.f0.thin1.m.r = r_01; stat.f0.thin1.m.t2 = stat.f0.thin1.f.t2; stat.f0.thin1.m.ER = [];
    else
      stat = ssd_mod(model, stat, '01m', par, T, f_01, 0); stat.f0.thin1.m.ER = [];
    end
    if n_fVal == 3
      stat.ff.thin1.m.f = stat.ff.thin1.f.f; stat.ff.thin1.m.r = stat.ff.thin1.f.r; stat.ff.thin1.m.t2 = stat.ff.thin1.f.t2; stat.ff.thin1.m.ER = [];
      if isnan(stat.ff.thin1.f.f)
        stat = ssd_mod(model, stat, 'f1m', NaN); stat.ff.thin1.m.f = NaN; stat.ff.thin1.m.ER = [];
      else
        stat = ssd_mod(model, stat, 'f1m', par, T, f_f1, r_f1); stat.ff.thin1.m.ER = [];
      end
    end
    stat.f1.thin1.m.f = stat.f1.thin1.f.f; stat.f1.thin1.m.r = stat.f1.thin1.f.r; stat.f1.thin1.m.t2 = stat.f1.thin1.f.t2;
    stat = ssd_mod(model, stat, '11m', par, T, 1, r_11); stat.f1.thin1.m.ER = [];
            
    par.thinning = 0;
    stat.f0.thin0.m.f = stat.f0.thin0.f.f; stat.f0.thin0.m.r = stat.f0.thin0.f.r; stat.f0.thin0.m.t2 = stat.f0.thin0.f.t2;
    if isnan(stat.f0.thin0.f.f) 
      stat = ssd_mod(model, stat, '00m', NaN); stat.f0.thin0.m.f = NaN; stat.f0.thin0.m.ER = [];
    else
      stat = ssd_mod(model, stat, '00m', par, T, f_00, 0); stat.f0.thin0.m.ER = [];
    end
    if n_fVal == 3
      stat.ff.thin0.m.f = stat.ff.thin0.f.f; stat.ff.thin0.m.r = stat.ff.thin0.f.r; stat.ff.thin0.m.t2 = stat.ff.thin0.f.t2;
      if isnan(stat.ff.thin0.f.f)
        stat = ssd_mod(model, stat, 'f0m', NaN); stat.ff.thin0.m.f = NaN; stat.ff.thin0.m.ER = [];
      else
        stat = ssd_mod(model, stat, 'f0m', par, T, f_f0, r_f0); stat.ff.thin0.m.ER = [];
      end
    end
    stat.f1.thin0.m.f = stat.f1.thin0.f.f; stat.f1.thin0.m.r = stat.f1.thin0.f.r; stat.f1.thin0.m.t2 = stat.f1.thin0.f.t2; 
    stat = ssd_mod(model, stat, '10m', par, T, 1, r_10); stat.f1.thin0.m.ER = [];   
  end
  
  % add statistics to output structure
%   txtStat.units.f   = '-';   txtStat.label.f   = 'scaled functional response';
%   txtStat.units.r   = '1/d'; txtStat.label.r   = 'spec pop growth rate';
%   txtStat.units.t2  = 'd';   txtStat.label.t2  = 'population doubling time';
%   txtStat.units.T   = 'C';   txtStat.label.T = 'body temperature'; 
%   txtStat.units.c_T = '-';   txtStat.label.c_T = 'temperature correction factor'; 

  % graphics
 
  Hfig_surv = figure(1); % survivor prob
  if n_fVal == 2
    plot(stat.f1.thin0.f.tS(:,1), log(stat.f1.thin0.f.tS(:,2)), 'r', ...
         stat.f0.thin0.f.tS(:,1), log(stat.f0.thin0.f.tS(:,2)), 'b', ...
         stat.f1.thin1.f.tS(:,1), log(stat.f1.thin1.f.tS(:,2)), '-.r',  ...
         stat.f0.thin1.f.tS(:,1), log(stat.f0.thin1.f.tS(:,2)), '-.b', ...
         'Linewidth', 2)
  else % n_fVal == 3
    plot(stat.f1.thin0.f.tS(:,1), log(stat.f1.thin0.f.tS(:,2)), 'r', ...
         stat.ff.thin0.f.tS(:,1), log(stat.ff.thin0.f.tS(:,2)), 'm', ...
         stat.f0.thin0.f.tS(:,1), log(stat.f0.thin0.f.tS(:,2)), 'b', ...
         stat.f1.thin1.f.tS(:,1), log(stat.f1.thin1.f.tS(:,2)), '-.r',  ...
         stat.ff.thin1.f.tS(:,1), log(stat.ff.thin1.f.tS(:,2)), '-.m',  ...
         stat.f0.thin1.f.tS(:,1), log(stat.f0.thin1.f.tS(:,2)), '-.b', ...
         'Linewidth', 2)
  end
  xlabel('age, d'); ylabel('ln survival probability');
  set(gca, 'FontSize', 15, 'Box', 'on');

  Hfig_stab = figure(2); % stable age distribution
  if n_fVal == 2
    plot(stat.f1.thin0.f.tSs(:,1), log(stat.f1.thin0.f.tSs(:,2)), 'r', ...
         stat.f0.thin0.f.tSs(:,1), log(stat.f0.thin0.f.tSs(:,2)), 'b', ...
         stat.f1.thin1.f.tSs(:,1), log(stat.f1.thin1.f.tSs(:,2)), '-.r',  ...
         stat.f0.thin1.f.tSs(:,1), log(stat.f0.thin1.f.tSs(:,2)), '-.b', ...
         'Linewidth', 2)
  else % n_fVal == 3
    plot(stat.f1.thin0.f.tSs(:,1), log(stat.f1.thin0.f.tSs(:,2)), 'r', ...
         stat.ff.thin0.f.tSs(:,1), log(stat.ff.thin0.f.tSs(:,2)), 'm', ...
         stat.f0.thin0.f.tSs(:,1), log(stat.f0.thin0.f.tSs(:,2)), 'b', ...
         stat.f1.thin1.f.tSs(:,1), log(stat.f1.thin1.f.tSs(:,2)), '-.r',  ...
         stat.ff.thin1.f.tSs(:,1), log(stat.ff.thin1.f.tSs(:,2)), '-.m',  ...
         stat.f0.thin1.f.tSs(:,1), log(stat.f0.thin1.f.tSs(:,2)), '-.b', ...
         'Linewidth', 2)
  end
  xlabel('age, d'); ylabel('ln survivor fn of stable age distr');
  set(gca, 'FontSize', 15, 'Box', 'on');



##### SOURCE END #####
--></body></html>